/*! 
\page users_guide Users Guide

\section ug_introduction Introduction
The \c itbase library is the core of \c IT++ and it contains classes and functions for
mathematics with scalars, vectors, and matrices.
This document does not cover all the aspects of the \c itbase
library. It does however explain the most important things you need to know in
order to start using it. Once you are more familiar with the \c itbase
library you will find the online reference manual more useful. 

\section ug_itpp_predefined_types Predefined Data Types

\subsection ug_itpp_scalar_types Predefined Scalar Types
Apart from the standard C++ types e.g. \c char, \c short, \c int, \c long, \c double, \c float, and \c long \c long,
the following types are specific for \c IT++:
<ul>
<li> \c complex<double>: Contains a real part and an imaginary part of type \c double. </li> 
<li> \c bin: Used for binary (0,1) data. </li>
</ul>

\subsection ug_itpp_vector_types Prepared Vector Types
A vector can in principle be of arbitrary type (that support addition, subtraction, multiplication and division),
since the general vector class \c Vec<TYPE> is templated. However, the most commonly used vector types are
predefined. These predefined vector types are:
<ul>
<li> \c vec: Basic vector type containing \c double. </li>
<li> \c cvec: Vector type containing \c complex<double>. </li>
<li> \c ivec: Vector type containing \c int. </li>
<li> \c bvec: Vector type containing \c bin. </li>
<li> \c svec: Vector type containing \c short. </li>
</ul>
The general vector class is used to define the specialized classes above. The
\c vec class is actually a \c Vec<double>. We urge you to use these predefined
classes instead of \c Vec<TYPE> when ever possible.

\subsection ug_itpp_matrix_types Prepared Matrix Types
The general matrix class is called \c Mat<TYPE>. These predefined matrix types are:
<ul>
<li> \c mat: Basic matrix type containing double. </li>
<li> \c cmat: Matrix type containing \c complex<double>. </li>
<li> \c imat: Matrix type containing \c int. </li>
<li> \c bmat: Matrix type containing \c bin. </li>
<li> \c smat: Matrix type containing \c short. </li>
</ul>
As with vector, the general matrix class is used to define the specialized classes above. The \c mat class is thus a \c Mat<double>.
We urge you to use these predefined classes instead of \c Mat<TYPE> whenever possible.

\section ug_vectors Using Vectors
Vectors and matrices in \c IT++ are very similar. We therefore begin to
describe the vector class in detail and then briefly explain the differences
regarding matrices in the next section.

\subsection ug_defining_vectors Defining a Vector
A vector containing elements of type \c double is defined with:
\code
vec my_vector;
\endcode
However, this will not assign a size (memory) to the vector. To assign the size 10
to the vector we may use:
\code
vec my_vector(10);
\endcode
or
\code
vec my_vector;
my_vector.set_size(10,false);
\endcode
where the second parameter in the \c set_size call (\c true
or \c false) determines if you want to copy the contents of the old data area
into the new resized one, or not. This may be useful when down-sizing a vector, but in
this case it is not. It is also equivalent to use
\code
my_vector.set_length(10,false);
\endcode
instead of \c set_size.
Observe that a declared vector (or matrix) is not cleared (the element values
are undefined). To clear a vector we simply write
\code
my_vector.clear();
\endcode
or
\code
my_vector.zeros();
\endcode
To fill the vector with ones we write
\code
my_vector.ones();
\endcode
It is possible to retrieve the length (size) of a vector in any of the 
following ways:
\code
length_of_vector = my_vector.length();
length_of_vector = my_vector.size();
length_of_vector = length(my_vector);
\endcode
To assign values to a vector 
\code
vec  a = "0 0.7 5 9.3";        //that is a = [0 0.7 5 9.3]
ivec b = "0:5";                //that is b = [0 1 2 3 4 5]
vec  c = "3:2.5:13";           //that is c = [3 5.5 8 10.5 13]
ivec d = "1:3:5,0:2:4";        //that is d = [1 3 5 0 2 4]
vec e("1.2,3.4,5.6");          //that is e = [1.2 3.4 5.6]
vec f;
f.set("1.0 2.0 3.0 4.0");      //that is f = [1.0 2.0 3.0 4.0]
vec g;
g = f;                         //that is g is a copy of f
\endcode
A comma or a space character separates the vector elements. When assigning or retrieving a specific vector element use
\code
a(i) = 3.14;
a(i);
\endcode
for element number \a i. Vector elements are numbered such that \a a (0) denotes the
first element. It is also possible to use square brackets as in the C
language, i.e.
\code
a[i] = 3.14;
a[i];
\endcode
Parts or a vector are retrieved by
\code
a.left(3);   //a vector containing the first 3 elements of a
a.right(2);  //a vector containing the last 2 elements of a
a.mid(1,2);  //a vector containing the 2 elements starting with a(1)
a(2,4);      //a vector containing all elements from a(2) to a(4)
\endcode
If you have a vector called \a index_list containing indexes
(\a ivec) you may write
\code
//this gives a vector containing all elements in index_list
a(index_list); 
\endcode
If you have a \c bvec called e.g. \a bin_list you may write
\code
a.get(bin_list); //this gives a vector containing all elements a(i)
                 //for which bin_list(i) equals 1
\endcode
Have a look at the following example:
\code
#include "itbase.h"

int man() {
  vec a = linspace(0,1,11);
  ivec index_list = "3 5 2 2";
  bvec bin_list = "1 0 1 0 1 0 1 0 1 0 1";

  cout << "a = " << a << endl;
  cout << "a(index_list) = " << a(index_list) << endl;
  cout << "a.get(bin_list) = " << a.get(bin_list) << endl;
}
\endcode
When you run this program you will see
\code
a = [0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0]
a(index_list) = [0.3 0.5 0.2 0.2]
a(bin_list) = [0.0 0.2 0.4 0.6 0.8 1.0]
\endcode

\subsection ug_vector_manipulation Vector Manipulation
Below follows a listing of the most common vector manipulation commands that
are available. All examples are given for an \c ivec denoted \a my_ivec, but of course this
will work for other vector types as well.
<ul>
<li> \c shift_right:
\code
//Shift in scalar data (10) at position 0
my_ivec.shift_right(10);
     
//Shift in vector at position 0
my_ivec.shift_right("10 4"); 
\endcode
</li> 
<li> \c shift_left:
\code
//Shift in scalar data (10) at position Size()-1
my_ivec.shift_left(10);
     
//Shift in vector at position Size()-1
my_ivec.shift_left("10 4");
\endcode
</li> 
<li> \c replace_mid:
\code
//Replace part of vector from position (10) with the vector "11 13"
my_ivec.replace_mid(10,"11 13"); 
\endcode
</li> 
<li> \c del:
\code
//Delete element at index (10), making vector size one less
my_ivec.del(10);
\endcode
</li> 
<li> \c ins:
\code
//Insert element at index (10), making vector size one extra
my_ivec.ins(10);
\endcode
</li> 
<li> \c split:
\code
//Splits vector at pos (10). Returns first part, keep second part. 
ivec first_part = my_ivec.split(10);
\endcode
</li> 
<li> \c elem_mult:
\code
//Multiply two vectors element wise.
ivec my_product = elem_mult(my_invec1,my_ivec2);
\endcode
</li>  
</li> 
<li> \c elem_div:
\code
//Dividide two vectors element wise.
ivec my_product = elem_div(my_invec1,my_ivec2);
\endcode
</li>  
<li> \c Calculation: +, -, *, /
\code
a = my_ivec1 + my_ivec2;  //Addition of vectors
a = my_ivec + 10;         //Addition of vector and scalar
a = my_ivec1 - my_ivec2;  //Subtraction of vectors
a = my_ivec - 10;         //Subtraction of vector and scalar
a = my_ivec * 10;         //Multiplication of vector and scalar
a = my_ivec / 10;         //Division of vector and scalar
\endcode
</li>
<li> \c Calculation: +=, -=, *=, /=, |=
\code
a += my_ivec;  //Addition of vectors (a = a+my_ivec)
my_ivec += 10; //Addition of vector and scalar (10)
a -= my_ivec;  //Subtraction of vectors (a = a-my_ivec)
my_ivec -= 10; //Subtraction of vector and scalar (10)
my_ivec *= 10; //Multiplication of vector and scalar (10)
my_ivec /= 10; //Divsion of vector and scalar (10)
my_ivec |= a;  //Element wise division
\endcode
</li> 
<li> \c concat
\code
a = concat(my_ivec1, my_ivec2);  //concatenation of two vectors
\endcode
</li>
</ul>

\subsection ug_vector_converters Vector Converters
In order to convert e.g an \c ivec to a \c vec we can
write some thing like \c my_vec = \c to_vec(my_ivec). The
following converters are available: \c to_bvec, \c to_svec,
  \c to_ivec, \c to_vec, \c to_cvec.

\subsection ug_vector_functions Vector Functions
There are several functions that operate on vectors. Some examples are:
\c max, \c max_index, \c min, \c min_index, \c product, \c energy, \c geometric_mean,
\c mean, \c median, \c norm, \c round, \c variance, \c ceil_i, \c floor_i, 
\c round_i, \c find.
Examples of functions that generate different kinds of vectors are
\c linspace, \c ones_b, \c ones_c, \c ones_i, \c ones \c zeros_b. There are several
more than these. Please refer to the IT++ reference manual for a description of these.

\section ug_matrices Using Matrices
Matrices are two-dimensional arrays, and most of their functionality is
similar to that of vectors. The predefined matrix types are \c mat, \c cmat,
  \c imat, \c smat, and \c bmat. Below follows some examples that are
specific for matrices only:
<ul>
<li> Define a matrix of type \c double with 3 rows and 4 columns
\code
mat a(3,4);
\endcode
</li> 
<li> Define a matrix of type \c int with 2 rows and 3 columns.
A comma (,) or space is used to separate columns and a
semicolon (;) is used to separate rows.
\code
imat a = "1 2 3;4 5 6";
\endcode
</li> 
<li> Access to rows and columns with \c get_row and \c get_col
\code
a.get_row(1); //Returns the second row of the matrix b
a.get_col(0); //Returns the first column of the matrix b
\endcode
</li> 
<li> Set rows and columns with \c set_row and \c set_col
\code
a.set_row(1,"9 8 7"); //Set second row to "9 8 7"
a.set_col(0,"7 2");   //Set first column to "7 2"
\endcode
</li> 
<li> The size of a matrix
\code
    //Set the size. "false" means "do not copy"
    a.set_size(4,5,false);
    int nr_of_rows = a.rows();    //return the number of rows
    int nr_of_columns = a.cols(); //return the number of columns
\endcode
</li>   
<li> Access to parts of a matrix
\code
    a(r,c); //Access to a single element.
    a(i);   //Access to a single element. Linear addressing, by rows.

    //Returns the sub-matrix from rows r1 to r2 and columns c1 to c2.
    a(r1,r2,c1,c2);
\endcode
</li> 
<li> Copy rows and columns
\code
    //Copy row number "from" to row number "to"
    a.copy_row(to,from)

    //Copy column number "from" to column number "to"
    a.copy_col(to,from) 
\endcode
</li> 
<li> Swap rows and columns
\code
    //Swap rows number r1 and r2
    a.swap_row(r1,r2)

    //Swap columns number c1 and c2
    a.swap_col(c1,c2) 
\endcode
</li> 
<li> Horizontal and vertical concatenation
\code
    //Equivalent to the MATLAB command c = [a b]
    c = concat_horizontal(a,b);

    //Equivalent to the MATLAB command c = [a;b]
    c = concat_vertical(a,b);
\endcode
</li>    
</ul>

\subsection ug_matrix_converters Matrix Converters
The following converters are available: \c to_mat, \c to_imat, \c to_cmat, \c to_bmat.

\section ug_array_class The Array Class
The \c itbase library contains, among other things, the\c Array class.
An \c Array can contain any type of data. Below is an example of an
\c Array containing vectors (\c vec):
\code
    #include "itbase.h"

    int main() {
        Array<vec> my_vec_array(2);
        my_vec_array(0) = linspace(0,1,4);
        my_vec_array(1) = "0.1 0.2 0.3 0.4 0.3 0.2 0.1";
        cout << "my_vec_array = " << my_vec_array << endl;

        return 0;
    }
\endcode

\section ug_random_variables Random Vectors, Matrices, and Generators

\subsection ug_random_vec_mat Random Vectors and Matrices
Random vectors and matrices are easily obtained by using these
predefined functions:
<ul>
<li> \c randb: Generates a random bit vector or matrix. </li>
<li> \c randu: Generates a random uniform vector or matrix. </li>
<li> \c randi: Generates a random index vector or matrix. </li>
<li> \c randray: Generates a random Rayleigh vector or matrix. </li>
<li> \c randrice: Generates a random Rice vector or matrix. </li>
<li> \c randexp: Generates a random Exponential vector or matrix. </li>
<li> \c randn: Generates a random Gaussian vector or matrix. </li>
<li> \c randn_c: Generates a random complex Gaussian vector or matrix. </li>
</ul>

\subsection ug_rng Random Number Generators (RNG)
The following discrete valued random number generators are
available. More information about these can be found in the IT++ reference manual.
<ul>
<li> \c Bernoulli_RNG </li>
<li> \c I_Uniform_RNG </li>
</ul>
The following continuous valued random number generators are
available.
<ul>
<li> \c Uniform_RNG </li>
<li> \c Exponential_RNG </li>
<li> \c Normal_RNG </li>
<li> \c Complex_Normal_RNG </li>
<li> \c AR1_Normal_RNG </li>
<li> \c Weibull_RNG </li>
<li> \c Rayleigh_RNG </li>
<li> \c Rice_RNG </li>
</ul>
  
\section ug_deterministic_sources Deterministic Sources
The following deterministic sources are
available. 
<ul>
<li> \c Sine_Source </li>
<li> \c Square_Source </li>
<li> \c Triangle_Source </li>
<li> \c Sawtooth_Source </li>
<li> \c Impulse_Source </li>
<li> \c Pattern_Source </li>
</ul>

\section ug_filters Filter Classes and Functions
The following filter classes are
available. 
<ul>
<li> \c AR_Filter </li>
<li> \c MA_Filter </li>
</ul>
The following filter functions are
available. 
<ul>
<li> \c filter </li>
</ul>

\subsection ug_signal_processing_func Signal Processing Functions
The following signal processing functions are
available. 
<ul>
<li> \c a2k, \c k2a, \c a2lar, \c k2lar, \c lpc, \c levinsson, \c lerouxguegen </li>
<li> \c fft, \c ifft </li>
<li> \c spectrum </li>
<li> \c cov, \c xcorr </li>
<li> \c chirp </li>
<li> \c dht, \c dht2, \c dwht, \c dhwt2, \c self_dht, \c self_dwht </li>
<li> \c filter_spectrum </li>
<li> \c filter_whiteness </li>
</ul>

\section ug_real_timer_class Timer Classes
The \c Real_Timer class can be used to measure execution time of a program as
in the following example:
\code
    #include "itbase.h"

    int main() {
        long i;
        long sum = 0;
        Real_Timer my_timer;

        my_timer.tic();
        for (i=0; i<10000000; i++) {
            sum += i;
        }
        my_timer.toc_print();

        cout << "The sum is " << sum << endl;

        return 0;
    }
\endcode

\section ug_itfile_class Reading and Writing to Files
The following example saves the variable \a a to the file
\c my_file_name.it: 
\code
    #include "itbase.h"

    int main() {
        it_file my_file("my_file_name.it");
        vec a = "1.0 2.0 3.0 4.0";
        my_file << Name("a") << a;

        return 0;
    }
\endcode
The following example reads the variable \a a from the file
\c my_file_name.it and prints it: 
\code
    #include "itbase.h"

    int main() {
        it_file my_file("my_file_name.it");
        vec a;
        my_file >> Name("a") >> a;
        cout << "a = " << a << endl;

        return 0;
    }
\endcode
Note that ".it"-files can be read and written by MATLAB by using the
functions \c load_it.m and \c save_it.m.
Also available is the class \c it_ifile that can only be used for
reading of files. 

\section ug_comm_lib The itcomm Library
The \c itcomm library contains many different communication
functions such as modulators and demodulators, channel encoders and
decoders, spreading and de-spreading functions, channel classes,
interleavers, e.t.c. 

\subsection ug_comm_modulator_class Modulator Classes
There is a base modulator class called \c Modulator and two
derived classes \c Modulator_1d and \c Modulator_2d.
You can use \c Modulator_1d to define you own 1-dimensional
signal constellations (e.g. BPSK and PAM) and \c Modulator_2d
to define you own 2-dimensional signal constellations (e.g. QPSK, QAM
e.t.c)

The predefined one and two dimensional constellation classes are
\c BPSK, \c PAM, \c PSK, \c QAM, and
\c QPSK.

\subsection ug_comm_channel_class Channel Classes
The following channel classes are available in \c itcomm:
\c AWGN_Channel, \c Multipath_Rayleigh_Channel,
\c Rayleigh_Channel, \c BSC, and \c Rice_Channel. Read more
about these channel classes in the IT++ reference manual.

\subsection ug_comm_error_control_class Error Control Classes
The following error control classes are available in \c itcomm:
\c Turbo_Codec, \c BCH, \c Reed_Solomon,
\c Convolutional_Code, \c Punctured_Convolutional_Code, \c Hamming_Code,
\c Rec_Syst_Conv_Code. 

\subsection ug_comm_spreading_class Spreading Classes
The following spreading classes are available in \c itcomm:
\c Spread_1d, \c Spread_2d,
\c Multicode_Spread_1d, \c Multicode_Spread_2d. Also,
the class \c Gold can be used to generate Gold spreading
sequences. 

\subsection ug_comm_interleaver_class Interleaver Classes
The following interleaver classes are available in \c itcomm:
\c Block_Interleaver, \c Cross_Interleaver,
and \c Sequence_Interleaver. 

*/
